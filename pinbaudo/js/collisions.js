//Ray collision detection and boundaries checkBoundaries
var collision = {
  collisionDetection:function(ball, obj){
		let c_ball = ball.pos();
		let v_ball = ball.vert;

    //Compute ball vertices in world space
		var vert_list = []; // ball vertices
		for (let i=0; i<(v_ball.length-2); i=i+3){
			var world_v = utils.multiplyMatrixVector(ball.worldM, [v_ball[i], v_ball[i+1], v_ball[i+2], 1.0]);

      if(world_v[2]/world_v[3] > ball.pos()[2] && Math.abs(world_v[1]/world_v[3] - ball.pos()[1]) < 0.05){
			   vert_list.push([world_v[0]/world_v[3], world_v[1]/world_v[3], world_v[2]/world_v[3]]);
      }
		}
		let ball_radius = utils.EuclideanDistance(c_ball, vert_list[0]);

    //obj is a vector of objects to be checked for collisions with the ball
    for(let k=0; k<obj.length; k++){

  		for(let i=0; i<vert_list.length; i++){

  			let cur_v = vert_list[i];
        //Parameters of the line starting from the ball center and going toward the current vertex
  			let line_par = [c_ball[0], (cur_v[0] - c_ball[0]), c_ball[1], (cur_v[1] - c_ball[1]), c_ball[2], (cur_v[2] - c_ball[2])];
        //find all the planes defined by the colliding object normals
        for (let j=0; j<obj[k].ind.length-2; j=j+3){

          //Find the normal in world space corresponding to index j
				  var n = utils.multiplyMatrix3Vector3(utils.sub3x3from4x4(obj[k].worldM), [obj[k].norm[obj[k].ind[j]*3], obj[k].norm[obj[k].ind[j]*3 + 1], obj[k].norm[obj[k].ind[j]*3 + 2]]);

          //Exclude collisions with short part when palletes are not moving
          if(obj[k].name == "paletteL" && obj[k].angle == -45 && n[0]>0 && n[2]>0){
            continue;
          }
          if(obj[k].name == "paletteL" && obj[k].angle == 30 && n[0]>0 && n[2]<0){
            continue;
          }

          if(obj[k].name == "paletteR" && obj[k].angle == -45 && n[0]<0 && n[2]>0){
            continue;
          }
          if(obj[k].name == "paletteR" && obj[k].angle == 30 && n[0]<0 && n[2]<0){
            continue;
          }

          //Find the vertices in world space corresponding to the normal we've just found
  				var p = [];
  				p[0] = utils.multiplyMatrixVector(obj[k].worldM, [obj[k].vert[obj[k].ind[j]*3], obj[k].vert[obj[k].ind[j]*3+1], [obj[k].vert[obj[k].ind[j]*3 + 2]],1]).slice(0,3);
  				p[1] = utils.multiplyMatrixVector(obj[k].worldM, [obj[k].vert[obj[k].ind[j+1]*3], obj[k].vert[obj[k].ind[j+1]*3+1], [obj[k].vert[obj[k].ind[j+1]*3 + 2]],1]).slice(0,3);
  				p[2] = utils.multiplyMatrixVector(obj[k].worldM, [obj[k].vert[obj[k].ind[j+2]*3], obj[k].vert[obj[k].ind[j+2]*3+1], [obj[k].vert[obj[k].ind[j+2]*3 + 2]],1]).slice(0,3);

          //Having a point (vertex) and a normal (n) you can compute a plane
  				var d = n[0]*p[0][0] + n[1]*p[0][1] + n[2]*p[0][2];
  				var plane_par = [n[0], n[1], n[2], d];

          //Check intersection between line from ball center toward cur_v and plane defined by obj normal and vertices
  				var t_coeff = plane_par[0]*line_par[1] + plane_par[1]*line_par[3] + plane_par[2]*line_par[5];
          //if t_coeff is 0 then there is no intersection
  				if (t_coeff==0){
  					continue;
  				}

          //if there is an intersection compute the distance between the intersection point and the ball center
  				var t = (- plane_par[0]*line_par[0] - plane_par[1]*line_par[2] - plane_par[2]*line_par[4] + plane_par[3])/t_coeff;
  				var int_point = [line_par[0] + t*line_par[1], line_par[2] + t*line_par[3], line_par[4] + t*line_par[5]];
  				let dist = utils.EuclideanDistance(int_point, c_ball);

          //if the distance is greater than the ball radius there is NO COLLISION
  				if (dist > ball_radius){
  					continue;
  				}

          //If a collision is detected, check if the intersection point is inside the triangle generated by the vertices of the obj.
          //This is because the plane is infinite, and we must check if the collision is actually occurred with the object.
  				var test = utils.pInTriangle(int_point, [p[0], p[1], p[2]]);

  				if (test==true){
            if(soundON){audioPalette.play();}
            scoreNum++;
            //When a collision is detected update ball velocity
            velocityUpdate.palettesVelUpdate(ball, obj[k], int_point);
            velocityUpdate.palettesWallVelUpdate(ball,obj[k], int_point);
            //Push back a little bit the ball to avoid going into palettes
            ball.set_pos(utils.MakeWorld(ball.pos()[0]-cur_v[0]+int_point[0], ball.pos()[1], ball.pos()[2]-cur_v[2]+int_point[2], anglex_ball*180/Math.PI, 0.0, anglez_ball*180/Math.PI));

            return null;
          }
        }
  		}
  	}
  },

  collisionCylinders: function(ball,cylinder){
    let c_ball = ball.pos();
    let ball_radius = 1.0;
    let cyl_radius = 1.0;

    for(let n=0;n<cylinder.length;n++){
      //cylinder's 4 vertices
      let ver = [];
      ver[0] = [cylinder[n].pos()[0]+1.0,cylinder[n].pos()[1],cylinder[n].pos()[2]];
      ver[1] = [cylinder[n].pos()[0]-1.0,cylinder[n].pos()[1],cylinder[n].pos()[2]];
      ver[2] = [cylinder[n].pos()[0],cylinder[n].pos()[1],cylinder[n].pos()[2]+1.0];
      ver[3] = [cylinder[n].pos()[0],cylinder[n].pos()[1],cylinder[n].pos()[2]-1.0];

      let k =[];
      //Check collisions
      if(utils.EuclideanDistance(c_ball, cylinder[n].pos()) <= ball_radius+cyl_radius){
        if(soundON){audioBumper.play();}
        scoreNum += 3;
        ball.set_vel([-ball.vel[0],0.0,-ball.vel[2]]);

        //To reposition the ball to avoid going into cylinders check to which of the 4 vertices the ball is closest
        for(let i=0;i<4;i++){
          k[i]= utils.EuclideanDistance(ver[i],c_ball);
        }
        let q = 0;
        let min = k[0];
        for(let i=0;i<4;i++){
          for(let j=0;j<4;j++){
            min = Math.min(min,k[j]);
            }
          }
        for(let i=0;i<4;i++){
          if(k[i]==min){
            q=i;
          }
        }
        if(q==0){
          //Push back a little bit the ball to avoid going into walls
          ball.set_pos(utils.MakeWorld(ball.pos()[0]+0.2, ball.pos()[1], ball.pos()[2], anglex_ball*180/Math.PI, 0.0, anglez_ball*180/Math.PI));
        }
        else if(q==1){
          //Push back a little bit the ball to avoid going into walls
          ball.set_pos(utils.MakeWorld(ball.pos()[0]-0.2, ball.pos()[1], ball.pos()[2], anglex_ball*180/Math.PI, 0.0, anglez_ball*180/Math.PI));
        }
        else if(q==2){
          //Push back a little bit the ball to avoid going into walls
          ball.set_pos(utils.MakeWorld(ball.pos()[0], ball.pos()[1], ball.pos()[2]+0.2, anglex_ball*180/Math.PI, 0.0, anglez_ball*180/Math.PI));
        }
        else if(q==3){
          //Push back a little bit the ball to avoid going into walls
          ball.set_pos(utils.MakeWorld(ball.pos()[0], ball.pos()[1], ball.pos()[2]-0.2, anglex_ball*180/Math.PI, 0.0, anglez_ball*180/Math.PI));
        }
        if(cylinder[n].name == "cyl1"){
          cylCol1 = [0.9,1.0,0.1];
        }
        if(cylinder[n].name == "cyl2"){
          cylCol2 = [0.9,1.0,0.1];
        }
        if(cylinder[n].name == "cyl3"){
          cylCol3 = [0.9,1.0,0.1];
        }
      }
    }

  },

  checkBoundaries:function(ball, wallL, wallR, wallU, wallD, paletteL, paletteR){
    let c_ball = ball.pos();
    let ball_radius = 1.0;
    let c_wL = wallL.pos();
    let c_wR = wallR.pos();
    let c_wU = wallU.pos();
    let c_wD = wallD.pos();
    let c_pL = paletteL.pos();
    let c_pR = paletteR.pos();
    //Check game lost
    if((c_ball[0] > -4 && c_ball[0] < 4 && c_ball[2] + ball_radius > 18.5) || (c_ball[2]+0.3 > c_pL[2] && c_ball[0] < 0 && p1UP) || (c_ball[2]+0.3 > c_pR[2] && c_ball[0] > 0 && p2UP)){
      if(soundON){audioLoose.play();}
      document.getElementById("Lost").style.visibility = "visible";
      recentered = true;
      cx = 0.0;
      cy = 10.0;
      cz = 25.0;
      elevation = -25.0;
      angle = 0.0;
      lookRadius = 30.0;
    }
    if(c_ball[0] - ball_radius < c_wL[0] + 1.0){
      ball.set_vel([-k_dissip*ball.vel[0],0.0,k_dissip*ball.vel[2]]);
      //Push back a little bit the ball to avoid going into walls
      ball.set_pos(utils.MakeWorld(ball.pos()[0]+0.2, ball.pos()[1], ball.pos()[2], anglex_ball*180/Math.PI, 0.0, anglez_ball*180/Math.PI));
    }
    if(c_ball[0] + ball_radius > c_wR[0] -1.0){
      ball.set_vel([-k_dissip*ball.vel[0],0.0,k_dissip*ball.vel[2]]);
      //Push back a little bit the ball to avoid going into walls
      ball.set_pos(utils.MakeWorld(ball.pos()[0]-0.2, ball.pos()[1], ball.pos()[2], anglex_ball*180/Math.PI, 0.0, anglez_ball*180/Math.PI));
    }
    if(c_ball[2] - ball_radius < c_wU[2] + 0.5){
      ball.set_vel([+k_dissip*ball.vel[0],0.0,-k_dissip*ball.vel[2]]);
      //Push back a little bit the ball to avoid going into walls
      ball.set_pos(utils.MakeWorld(ball.pos()[0], ball.pos()[1], ball.pos()[2]+0.2, anglex_ball*180/Math.PI, 0.0, anglez_ball*180/Math.PI));
    }
    if(c_ball[2] + ball_radius > c_wD[2] - 0.5){
      ball.set_vel([+k_dissip*ball.vel[0],0.0,-k_dissip*ball.vel[2]]);
      //Push back a little bit the ball to avoid going into walls
      ball.set_pos(utils.MakeWorld(ball.pos()[0], ball.pos()[1], ball.pos()[2]-0.2, anglex_ball*180/Math.PI, 0.0, anglez_ball*180/Math.PI));
    }
  }
}

var velocityUpdate = {
  palettesVelUpdate:function(ball, obj, int_point){
    //Collision with palettes
    //If the palette is in movement, then adjust ball velocity
    if(obj.name == "paletteL" || obj.name == "paletteR"){
      if(obj.angle != obj.max_angle && obj.angle != obj.min_angle){
      obj_vel = obj.get_vel(deltaRot, int_point);
      ball.set_vel([(obj_vel[0]+ball.vel[0])*k_dissip_pal, 0.0, (-obj_vel[2]-ball.vel[2])*k_dissip_pal]);
    }
    //else if the palette is not in movement, then adjust ball velocity in another way
      else{
        if(obj.name == "paletteL"){
          if(obj.angle == obj.max_angle){
          norm_vel = utils.normalizeVec3([-ball.vel[0],-ball.vel[1],-ball.vel[2]]);
          norm_plane = [Math.cos(utils.degToRad(-obj.max_angle)), 0.0, -Math.sin(utils.degToRad(-obj.max_angle))];
          //Compute the angle between the palette normal and the ball velocity normal
          scalar_prod = norm_vel[0]*norm_plane[0] + norm_vel[1]*norm_plane[1] + norm_vel[2]*norm_plane[2];
          alpha = Math.acos(scalar_prod);

          v = utils.normVec3(ball.vel);
          v_x = v*Math.sin(alpha);
          v_z = v*Math.cos(alpha);
          ball.set_vel([k_dissip_pal*v_x, 0.0,-k_dissip_pal*v_z ]);
        }
          if(obj.angle == obj.min_angle){
          norm_vel = utils.normalizeVec3([-ball.vel[0],-ball.vel[1],-ball.vel[2]]);
          norm_plane = [-Math.cos(utils.degToRad(obj.min_angle+90)), 0.0, -Math.sin(utils.degToRad(obj.min_angle+90))];
          //Compute the angle between the palette normal and the ball velocity normal
          scalar_prod = norm_vel[0]*norm_plane[0] + norm_vel[1]*norm_plane[1] + norm_vel[2]*norm_plane[2];
          alpha = Math.acos(scalar_prod);

          v = utils.normVec3(ball.vel);
          v_x = v*Math.sin(alpha);
          v_z = v*Math.cos(alpha);
          ball.set_vel([-k_dissip_pal*v_x, 0.0,-k_dissip_pal*v_z ]);
        }
        }

        if(obj.name == "paletteR"){
          if(obj.angle == obj.max_angle){
          norm_vel = utils.normalizeVec3([-ball.vel[0],-ball.vel[1],-ball.vel[2]]);
          norm_plane = [-Math.cos(utils.degToRad(-obj.max_angle+90)), 0.0, -Math.sin(utils.degToRad(-obj.max_angle+90))];
          //Compute the angle between the palette normal and the ball velocity normal
          scalar_prod = norm_vel[0]*norm_plane[0] + norm_vel[1]*norm_plane[1] + norm_vel[2]*norm_plane[2];
          alpha = Math.acos(scalar_prod);

          v = utils.normVec3(ball.vel);
          v_x = v*Math.sin(alpha);
          v_z = v*Math.cos(alpha);
          ball.set_vel([-k_dissip_pal*v_x, 0.0,-k_dissip_pal*v_z ]);
        }
          if(obj.angle == obj.min_angle){
          norm_vel = utils.normalizeVec3([-ball.vel[0],-ball.vel[1],-ball.vel[2]]);
          norm_plane = [Math.cos(utils.degToRad(obj.min_angle-90)), 0.0, Math.sin(utils.degToRad(obj.min_angle-90))];
          //Compute the angle between the palette normal and the ball velocity normal
          scalar_prod = norm_vel[0]*norm_plane[0] + norm_vel[1]*norm_plane[1] + norm_vel[2]*norm_plane[2];
          alpha = Math.acos(scalar_prod);

          v = utils.normVec3(ball.vel);
          v_x = v*Math.sin(alpha);
          v_z = v*Math.cos(alpha);
          ball.set_vel([+k_dissip_pal*v_x, 0.0,-k_dissip_pal*v_z ]);
        }
        }
      }

    }
  },

  palettesWallVelUpdate:function(ball, obj){
    if(obj.name == "palWallL" || obj.name == "palWallR"){
      if(obj.name == "palWallR"){
          norm_vel = utils.normalizeVec3([-ball.vel[0],-ball.vel[1],-ball.vel[2]]);
          norm_plane = [-Math.cos(utils.degToRad(45+90)), 0.0, -Math.sin(utils.degToRad(45+90))];
          //Compute the angle between the palette normal and the ball velocity normal
          scalar_prod = norm_vel[0]*norm_plane[0] + norm_vel[1]*norm_plane[1] + norm_vel[2]*norm_plane[2];
          alpha = Math.acos(scalar_prod);

          v = utils.normVec3(ball.vel);
          v_x = v*Math.sin(alpha);
          v_z = v*Math.cos(alpha);
          ball.set_vel([-k_dissip*v_x, 0.0,-k_dissip*v_z ]);

        }
      if(obj.name == "palWallL"){
          norm_vel = utils.normalizeVec3([-ball.vel[0],-ball.vel[1],-ball.vel[2]]);
          norm_plane = [Math.cos(utils.degToRad(45)), 0.0, -Math.sin(utils.degToRad(45))];
          //Compute the angle between the palette normal and the ball velocity normal
          scalar_prod = norm_vel[0]*norm_plane[0] + norm_vel[1]*norm_plane[1] + norm_vel[2]*norm_plane[2];
          alpha = Math.acos(scalar_prod);

          v = utils.normVec3(ball.vel);
          v_x = v*Math.sin(alpha);
          v_z = v*Math.cos(alpha);
          ball.set_vel([k_dissip*v_x, 0.0,-k_dissip*v_z ]);
        }
      }
    }
  }
